
What is Vertx?

 Vert.x is a tool-kit to build
       functional style,
       non blocking or async,
       poly glot,
       Event driven,
       Reactive, 
            Distributed Application(MicroService) on 
                       JVM
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Non Blocking and Async Programming:
..................................

Process
  Program in execution
    Program is collection of instructions
     instrction is collection of statements and expressions. 
       statement
               declarations - int a =10;
               expression s =  a+b , hello(),new Hello()

Memory
  Main memory - RAM
  Secondary  - DISK

Processor
  Where instructions and expressions are evaulated
  Processor gets expressions and declaration from main memory /processor registers.

Programs
  -passive
       which is not IN RAM / or /Program which is not accessed by CPU.
  -active
      Which is ram and excuted by CPU.
        -Process.

Runtime /Execution Engine/Machine:
..................................

   Container Active Programm, which acts as bridge between app and os.

Every pl , has its own runtime - java
 - JVM.

any thing inside ram- will have structure : Process layout 

Heap:
  The ds for allocating dynamic memory .

Stack:
  The ds for  allocating dynamic memory.

Program data;

 it is ds for passive programs of running application.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Concurrency:
  Doing many thing, at the same time.

 -1960 ken thomson- MULTICS : MANY ACTIVE PROGRAMS ON CPU AT THE SAME.
   -UNICS - UNIX
-YOU CAN RUN MANY PROCESS AT THE SAME TIME - BY USING TIME SHARING ALRGORITHM.
 -MULTI PROCESS.

WE CANT RUN MORE PROCESS AT THE SAME TIME - VERY LIMIMED MEMORY.

SUBPROCESS : thread of execution.
  -to execute parrell tasks for given process
 eg: 
   printing,sending email,read data from database,talking to sockets

mutlti thread :
  on single , doing many concurrent tasks.

Multi threading:

1.each thread is created for spefici task.
2.threads can communicate each other for data exchange.
   eg:
     IN Http, the HTTP Socket is waiting for pdf file to send to client

Blocking and Sync Programming model:

 1.process need to create,allocate,execute, remove threads : life cycle of threads
  
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Types of Conncurrency:

1.Process(jvm) level concurrency  :Blocking and Sync
   - creates and manages life of threads.

if more threads, process will suffer from
 -performance
 -dead lock
 -race conditions
......

2.Worker thread level Concurrency: Nonblocking and async.



Reactor Design Pattern:

Reactor design pattern is used to build /design any non blocking/async architechure.


Reactor Design pattern implementation:
.....................................

1.Node js - the most popular reference implmentation of reactor design pattern
2.vertx
3.nginx
...........

Vertx and Non blocking:
.........................
History of Vert.x? -Verticle.Extension

 -Tim fox, who created vertx similar to node.js but on jvm.
 -inital project name was - "Node.x"
      due to copy right, node.x was renamed to vert.x.
- Vert.x is donated to Ecplise foundation. Ecplise Vertx

-Now vertx is largly promoted by "Red Hat"

Architecture of Vertx;Reactor design pattern in java:
....................................................

How vertx is achiving nonblocking/async.
 

Java and Async Programming:
............................
   What if jvm supports non-blocking,evented concurrency?



Java 7 called Dolphin

   Dolphin  introduced  experimental model for building fast  disk IO, called “NIO” – NonBlocking IO when compare to traditional IO.


That was beginning
      Due to low support  from Java, only DISK IO was implemented.

Later it was improved, added TCP/IP IO was implemented  But it is still Not “Reactor Pattern Model”

Birth of Open Source Projects 
	to solve NON Blocking IO On JVM



NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns


 		      Netty Apps
		         |
          	      nettycore
			 |
			nio
			 |
		        jvm


Netty project provides:
1.nio only for disk io but netty provided more io like
   tcp/ip,sockets,udp,http
  non blocking
 netty uses "Reactor Model" internnaly


Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library



 		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm




Vertx:


Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM. initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

                   "Vertx has been built on the top of Netty Core"


	                VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM




NonBlocking IO Apis


                     NonBlocking IO Application
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as per JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
		|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				 |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
                                
          
/////////////////////////////////////////////////////////////////////////////////////////////////////

Dont call us,we will call you ----- Event Driven programming



Req : to read database records

  Client----req -----Vertx---|---delegate db operations--db

					db operations done
					<--inform vertx  - events
				callbackFunctions---result  - handlers



Vertx Tech Stack
  Build async,non blocking Apps

Spring is collection of projects called modules
  like core,data,mvc,integration,microservice.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

Vertx-Core:

Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   

////////////////////////////////////////////////////////////////////////////////////////

Does Vertx 100% NonBlocking Platform?
  Yes!, 
  But You can build Blocking applications as well.
  Some of the vertx API are blocking.
  YOu can integrate blocking and non blocking : mostly not recommened.


Event loop:
..........
   Vertx heart is event loop.
   It is a thread to handle events, and handlers.
   Event loop is going to process events in sync fashion from event queue.

Note :
  In node js, only one event loop per Node process.

 But in vertx , who decided to put more event loops to enchance performance.
                     
                          "Multi-Reactor Design Pattern"
    

But Vertx has many event many event loops , Per CPU 2 event loops.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

What if you block event loop thread itself?

  Vertx cant wait for long time for response, even though the code is non blocking, which will throw
warning
        "Thread vertx-eventloop-thread-3 has been blocked for 20458 ms"


                        "The Golden Rule - Don’t Block the Event Loop"

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&



Vertx-Core:
..........

Coding :


Vertx Application setup /Project Setup:
.......................................

ways :

1.maven
2.Gradle

1.plain maven project, add vertx depedencies,You can use template entry method provided by
vertx .

2.Vertx Starter project

3.Vertx maven cli project



Running:
To launch your tests:

./mvnw clean test
To package your application:

./mvnw clean package
To run your application:

./mvnw clean compile exec:java
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx Core Concepts:


1.Vertx Instance
2.Verticle


Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.


Objects in vertx Land:
..................... 
1.vertx instance
2.Verticle


Verticle :

  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loops.


Vertx gives you way to write vertx apps

 -with verticle  : recommended
 -without verticle : not recommended.


How to run vertx apps / how to deploy / pack vertx apps


Dev Mode:

1.you can use maven 
 mvn  clean compile exec:java
2.You can use utility class
  Vertx runner class : this is easy for development.

Production/embed inside other application:
...........................................
1.you can pack vertx as "fat" jar.
	maven-shade-plugin is used to create fat jar.
using fat jar model, you can lanuch application using java command

 $vertx-apps> java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar  
 HTTP server started on port 8888
 Jul 28, 2020 12:26


2.using vertx cli command
  -you dont run jar file
  -you dont run .class file
  -you dont need to compile the code
  -you run using source code.

:\session\ibm\july\Vertx\vertx-apps\src\main\java\com\ibm\vertx_apps>vertx run MainVerticle.java

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Lets start :


1.how to create vertx instance


Package io.vertx.core:
......................

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles



1.1. Vertx instance is created using factory apis
..................................................

To create an instance of this class you can use the static factory methods:
  vertx(), 
  vertx(io.vertx.core.VertxOptions) 
  clusteredVertx(io.vertx.core.VertxOptions, Handler).

package com.ibm.vertx.core;
import io.vertx.core.Vertx;


public class VertxInstanceCreationUsingFactory {
  public static void main(String[] args) {
    //Create Vertx instance
    Vertx vertx = Vertx.vertx();
    //
    System.out.println(vertx.toString());



  }
}

1.2.Vertx instance is created via one Base class 
    "AbstractVerticle"
  
 -used to get vertx instance reference.

 
package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class VertxInstanceCreationUsingAbstractVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(VertxInstanceCreationUsingAbstractVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello Vertx");
    System.out.println(vertx.toString());
  }

}

if you want to create your own verticles, then you have to inherit AbstractVerticle

if you inherit AbstractVertcle, vertx reference is availble automatically,you need not use
factory method.

Abstract verticle provides life cycle methods

start
  - is called once , you deploy the verticle on vertx
stop
 - is called once , you undeploy the verticle from vertx

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Verticles:

 -Object used to hold vertx non blocking archiecture
 -it is based on actor-like design pattern
 -Verticles are deployable unit.


How to create Our own verticles and how to deploy ?


package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.example.util.Runner;


class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter Verticle!!!");
  }

}

//main verticle
public class HelloWorldVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HelloWorldVerticle.class);
  }

  //override start method
  // @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello World  Verticle");
    //deploy greeter verticle
    vertx.deployVerticle(new GreeterVerticle());

  }
}
//way -2
//public class HelloWorldVerticle {
//  public static void main(String[] args) {
//    Vertx vertx = Vertx.vertx();
//    //deploy verticle
//    vertx.deployVerticle(new GreeterVerticle());
//  }
//}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx Handlers - Event Handlers:
................................

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern
2.Reactive Pattern - RxJava2

if you come from java script && node.js background,you know the concept called "Callback
function" - callback function is other wise called as "listener function" and "handler function".

1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.


The result of async opertion could be either success or failure

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

io.vertx.core

Interface Future<T>

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future




Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation
 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate
 inside this api.
    

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure


  AsyncResult interface apis

   -result() - get the success result sent by Future
   -cause()   -get the failure result sent by Future
   -succeed() -test whether it was success or failure
   -failed()  -test whether it was failure or success

..................................................................................................


Basic Use case:
package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

//Fututure Verticle

class FutureVerticle extends AbstractVerticle {

  //Future flavours
  //return empty Future
  private Future<Void> getEmptyFuture() {
    //Create Future Object ; using factor method
    Future future = Future.future();
    //send empty success result
    future.complete();
    //return future
    return future;
  }

  //How to return always success Result
  private Future<String> getDataFuture() {
    //Create Future Object ; using factor method
    Future future = Future.future();
    //send empty success result
    future.complete("Hello I am From Future");
    //return future
    return future;
  }

  //failures
  private Future<String> getErrorFuture() {
    //Create Future Object ; using factor method
    Future future = Future.future();
    //send empty success result
    future.fail("something went wrong!!!");
    //return future
    return future;
  }

  //how to send success or error based on biz logic.
  public Future<String> login() {
    //Create Future Object ; using factor method
    Future future = Future.future();

    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success");
    } else {
      future.fail("Login failed");
    }
    //return future
    return future;

  }

  @Override
  public void start() throws Exception {
    super.start();
    //caller
    //Test Empty Future
    if (getEmptyFuture().succeeded()) {
      System.out.println("Empty future is succeed");
    } else {
      System.out.println("Future failed");
    }
    //Grab Data via Future

    getDataFuture().setHandler(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> asyncResult) {
        //Test your operation is success or failed
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result());
        } else {
          System.out.println(asyncResult.cause().getMessage());
        }
      }
    });
    //
    getDataFuture().setHandler(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
    //using oncomplete
    getDataFuture().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });

    //handle failures
    getErrorFuture().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });

    //handle both success or failure

    login().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });

    //only success
    getDataFuture().onSuccess(result -> System.out.println(result));
    getDataFuture().onSuccess(System.out::println);

    //only errors
    getErrorFuture().onFailure(err -> System.out.println(err));
    getErrorFuture().onFailure(System.out::println);


  }
}


public class BasicFutureDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicFutureDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FutureVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//chaining : fluent pattern : builder pattern

//login()--Future.onSuccess()---Future---OnFailure().....

login().onSuccess(System.out::println).onFailure(System.out::println);


Promise:

Promise is async abstraction largly promoted by javascript community.
Dont Compare js javascript with Vertx Promise.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Fututre and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis

if you want process, you have to convert "Promise to Future" again.

promise conversion can be done when you process or promise conversion can be before process.

package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  private Future<Void> getEmptyPromise() {
    //Create Promise Object ; using factory method
    Promise promise = Promise.promise();
    //send empty success result
    promise.complete();
    //return future: convert Promise to
    return promise.future();
  }

  //how to send success or error based on biz logic.
  public Future<String> login() {
    //Create Future Object ; using factor method
    Promise promise = Promise.promise();
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login Success");
    } else {
      promise.fail("Login failed");
    }
    //return future
    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
    //Promise.future()-will convert Promise into future
    //getEmptyPromise().future().succeeded();
    String result = getEmptyPromise().succeeded() ? "Success" : "Failed";
    System.out.println(result);

    login().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
    //chaining : fluent pattern
    login().onSuccess(System.out::println).onFailure(System.out::println);

  }
}

public class BasicPromiseDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicPromiseDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
depedency operations  , should happen one by one

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - writeresults
 5.send/flush the results to clients - sendresponse

Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.



Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with input of getUser
                        |
		     if not
			 -error



Basic Callback Nesting :

package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class CallbackNestingVerticle extends AbstractVerticle {

  //getUser
  public Future<String> getUser() {
    Promise promise = Promise.promise();
    //biz logic
    String fakeUser = "Subramanian";
    if (fakeUser != null) {
      promise.complete(fakeUser);
    } else {
      promise.fail("User Not Found!!");
    }

    return promise.future();
  }

  //login
  public Future<String> login(String userName) {
    Promise promise = Promise.promise();
    //biz logic
    if (userName.equals("Subramanian")) {
      promise.complete("Login success ");
    } else {
      promise.fail("Login failed!!");
    }

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println("Get User is called");
        //nested callback
        login(asyncResult.result()).onComplete(asyncResult1 -> {
          System.out.println("Login is called");
          if (asyncResult1.succeeded()) {
            System.out.println(asyncResult1.result());
          } else {
            System.out.println(asyncResult1.cause().getMessage());
          }
        });
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }
    });
  }
}


public class NestedCallbackDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(NestedCallbackDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new CallbackNestingVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Nested Callback without onComplete/setHandler:
...............................................



package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

class UserApp extends AbstractVerticle {

  public void getUser(Handler<AsyncResult<String>> aHandler) {
    String fakeUser = "Subramanian";
    //biz logic
    if (fakeUser != null) {
      //handle success
      /**
       * asyncResult -> {
       *       if (asyncResult.succeeded()) {
       *         System.out.println(asyncResult.result());
       *       } else {
       *         System.out.println(asyncResult.cause().getMessage());
       *       }
       *
       *     }
       *     invocation
       */
      aHandler.handle(Future.succeededFuture(fakeUser));
    } else {
      aHandler.handle(Future.failedFuture("No User Found"));
    }

  }

  public void login(String userName, Handler<AsyncResult<String>> aHandler) {
    //biz logic
    if (userName.equals("Subramanian")) {
      //handle success
      aHandler.handle(Future.succeededFuture("Login Success"));
    } else {
      aHandler.handle(Future.failedFuture("Login failed"));
    }
  }

  public void showUserPage(String loginStatus, Handler<AsyncResult<String>> aHandler) {
    //biz logic
    if (loginStatus.equals("Login Success")) {
      //handle success
      aHandler.handle(Future.succeededFuture("Perumium User"));
    } else {
      aHandler.handle(Future.failedFuture("Guest"));
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //callback function
    getUser(asyncResult -> {
      System.out.println("get user.....");
      if (asyncResult.succeeded()) {
        login(asyncResult.result(), asyncResult1 -> {
          System.out.println("login......");
          if (asyncResult1.succeeded()) {
            //System.out.println(asyncResult1.result());
            //showUser page
            showUserPage(asyncResult1.result(), asyncResult2 -> {
              System.out.println("user page.....");
              if (asyncResult2.succeeded()) {
                System.out.println(asyncResult2.result());
              } else {
                System.out.println(asyncResult2.cause().getMessage());
              }
            });
          } else {
            System.out.println(asyncResult1.cause().getMessage());
          }
        });
      } else {
        System.out.println(asyncResult.cause().getMessage());
      }

    });
  }
}


public class NestedCallbackWithouOnComplete extends AbstractVerticle {


  public static void main(String[] args) {
    Runner.runExample(NestedCallbackWithouOnComplete.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserApp());
  }
}
******************************************************************************************

callback Hell:


 getUser(ar -> {
      if (ar.succeeded()) {
        System.out.println("Get User Method");
        login(ar.result(), lar -> {
          if (lar.succeeded()) {
            System.out.println(lar.result());
          } else {
            System.out.println(lar.cause());
          }
        });

      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!......This is  what we call is "callback hell".

foo.a(1, res1 -> {
  if (res1.succeeded()) {
    bar.b("abc", 1, res2 -> {
      if (res.succeeded()) {
         baz.c(res3 -> {
           dosomething(res1, res2, res3, res4 -> {
               // (...)
           });
         });
      }
    });
  }
});

can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Vertx provides solution : compose

package com.ibm.vertx.core.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;


//how to avoid callback hell:
class ComplexCallback extends AbstractVerticle {
  //prepareDatabase
  public Future<Void> prepareDatabase() {
    System.out.println("PrepareDatabase is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  public Future<Void> startHttpServer() {
    System.out.println("startHttpServer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  public Future<Void> startWebContainer() {
    System.out.println("startWebContainer is called");
    Promise promise = Promise.promise();
    promise.complete();
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    prepareDatabase().onComplete(dbar -> {
      //if database success,start http server
      if (dbar.succeeded()) {
        startHttpServer().onComplete(httpar -> {
          //if http success, start web container
          if (httpar.succeeded()) {
            startWebContainer().onComplete(webctar -> {
              if (webctar.succeeded()) {
                System.out.println("System is Up!!");
              } else {
                System.out.println("System is down!!!");
              }
            });
          }
        });
      } else {
        System.out.println(dbar.cause().getMessage());
      }
    });

    //avoid callback hell using compose method
    prepareDatabase()
      .compose(httpar -> {
        System.out.println("Extra server logic");
        return startHttpServer();
      })
      .compose(webar -> startWebContainer())
      .onComplete(status -> {
        if (status.succeeded()) {
          System.out.println("All Server : Compose is Ready!");
        } else {
          System.out.println("Server is down");
        }
      });

    prepareDatabase()
      .compose(httpar -> {
        System.out.println("Extra server logic");
        return startHttpServer();
      })
      .compose(webar -> startWebContainer())
      .onSuccess(res -> System.out.println("Server is up"))
      .onFailure(err -> System.out.println("Server is down"));
  }
}


public class CallbackHellSolution extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallbackHellSolution.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ComplexCallback());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Entering nonblocking and async applications:
............................................

1.All async operations are handled by event loop.

How to write async operations? / how to know that operations is async/non blocking?

//Blocking and sync:

class Test{ 

 public void readFile(){

Charset charset = Charset.forName("US-ASCII");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
 }

}

Vertx has its own version of apis to enable non blocking,those apis are non blocking apis.


vertx instance offers apis to handle non blocking
-Creating TCP clients and servers
-Creating HTTP clients and servers
-Creating DNS clients
-Creating Datagram sockets
-Setting and cancelling periodic and one-shot timers
-Getting a reference to the event bus API
-Getting a reference to the file system API
-Getting a reference to the shared data API


Async api classification:

1.Timer api
2.File System
3.HTTP api
4.TCP/ip api
5.Database drivers api - jdbc,mongo...



Timers api:
package com.ibm.vertx.core.async;

import io.vertx.core.*;
import io.vertx.example.util.Runner;


class Timer extends AbstractVerticle {

  //return result in async way
  public Future<String> delay(long timeout) {
    Promise promise = Promise.promise();
    //async operations
    vertx.setTimer(timeout, handler -> {
      //wrap result after timeout
      promise.complete("I am delayed Message : My time out " + timeout);
    });
    return promise.future();

  }

  /**
   * @param timeout This method cant return Future/Promise
   *                because this method once returns, -completes and removed from memory
   *                in second tick, it tries to look promise and return , there is no such implementation then
   *                it will throw illagalstateException
   */
  public void tick(long timeout) {
    //async operations
    vertx.setPeriodic(timeout, handler -> {
      //wrap result after timeout
      System.out.println("tick  at every  " + timeout + "ms");
    });
  }

  //callback version
  public void heartBeat(Handler<AsyncResult<String>> aHandler) {
    //return result after some time
    vertx.setPeriodic(1000, ar -> {
      //wrap the result into Future
      aHandler.handle(Future.succeededFuture("heart bea at every 1 sec"));
    });
  }


  //sync api
  private String status(String message) {
    return message;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(status("start"));
    delay(5000).onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
    delay(1000).onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
    //tick(1000);
    //the callback function is called for every timer iteration
    heartBeat(asyncResult -> {
      System.out.println(asyncResult.result());
    });
    System.out.println(status("end"));

  }
}


public class TimerApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimerApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new Timer());
  }
}

How to cancel timer which has been started?

  //callback version
  public void heartBeat(Handler<AsyncResult<String>> aHandler) {
    //return result after some time
    long timerId = vertx.setPeriodic(1000, ar -> {
      //wrap the result into Future
      aHandler.handle(Future.succeededFuture("heart beat at every 1 sec"));
    });
    vertx.setTimer(10000, ar1 -> {
      System.out.println("canceling");
      vertx.cancelTimer(timerId);
      System.exit(1);
    });
  }

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Vertx is good for non blocking application.
Vertx is good for non blocking io application.

IO :
 IO is every Where.
Every pl , traditionally blocking io.
Vertx offers nonblocking io  / async io : io operations never block current process,to be scheduled separatelly.

Types of io:
1.file system io  - read,write from disk files
2.Networking io -  http,tcp/ip,dns,datagram....
3.Database io

File System Api:
................
package com.ibm.vertx.core.async;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.file.FileSystem;
import io.vertx.example.util.Runner;

class FileServiceVerticle extends AbstractVerticle {

  private Future<String> readFile() {
    Promise promise = Promise.promise();
    //Async file read operation
    FileSystem fs = vertx.fileSystem();

    fs.readFile("assets/hello.txt", fileHandler -> {
      if (fileHandler.succeeded()) {
        System.out.println("File is ready!");
        promise.complete(fileHandler.result().toString());
      } else {
        promise.fail(fileHandler.cause());
      }
    });


    return promise.future();
  }

  private Future<String> readFileBlocking() {
    Promise promise = Promise.promise();
    //Async file read operation
    FileSystem fs = vertx.fileSystem();
    Buffer result = fs.readFileBlocking("assets/hello.txt");
    promise.complete(result.toString());
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start");
//    readFile().onComplete(far -> {
//      if (far.succeeded()) {
//        System.out.println(far.result());
//      } else {
//        System.out.println(far.cause().getMessage());
//      }
//    });
    readFileBlocking()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    System.out.println("end");
  }
}

public class FileSystemApp extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FileSystemApp.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FileServiceVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Golden Rule : Dont block event loop:
.....................................

There is no gurantee that vertx can offer 100% non blocking, what if i want to write blocking opertions
inside vertx.

-Non blocking operations are handled by "Event Loop" Thread.
-Blocking operations should be off loaded outside event loop thread, grab result carefully without 
 blocking event loop.


Blocking code :

1.Through verticle itself
2.Through vertx has api executeBlocking.


Verticle Types:

  There are two types of verticles

1.Standard Verticle
2.Worker Verticle


1.Standard Verticle :
   These types of verticles are the most common and usefull type - They are always executed using 
an event loop thread.

2.Worker Verticle
    These run using a thread from the "Worker Pool".
    An instance is never executed concurrently by more than one thread.

Before deploying verticle, you can tell that this verticle is "Worker" / "standard".

Verticle Meta Object: Verticle Configuration.
DeploymentOptions

io.vertx.core.DeploymentOptions
    
  Options for configuring a verticle deployment.

public DeploymentOptions setWorker(boolean worker)
Set whether the verticle(s) should be deployed as a worker verticle

How to deploy Verticle?

create verticle directly:

   vertx.deployVerticle(new VerticleInstance()); // with default configuration

create verticle via "VerticleFactory" ;; 
  factory will help initalize/deploy the verticle with customized configuration.

    vertx.deployVerticle("com.ibm.vertx.MyVerticle", deploymentOptions)


Blocking could be 

Thread.sleep() - will block the current thread



package com.ibm.vertx.core.async;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.example.util.Runner;


public class BlockingVerticleUsingWorkers extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleUsingWorkers.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //deploy standard verticle pattern
    //   vertx.deployVerticle(new WorkerVerticle());
    //deploy verticle as worker verticle
    //normal java pattern
//    DeploymentOptions options = new DeploymentOptions();
//    options.setWorker(true);

    //Vertx fluent api pattern
//    DeploymentOptions options = new DeploymentOptions().setWorker(true);
//    vertx.deployVerticle("com.ibm.vertx.core.async.WorkerVerticle", options);
    // DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle("com.ibm.vertx.core.async.WorkerVerticle", new DeploymentOptions().setWorker(true));

  }
}

package com.ibm.vertx.core.async;

import io.vertx.core.AbstractVerticle;

public class WorkerVerticle extends AbstractVerticle {


  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    //I am going block event loop.
    vertx.setPeriodic(10000, id -> {
      //Block Event loop thread.
      try {
        System.out.println("zzzzz");
        Thread.sleep(8000);
        System.out.println("wake up");
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
How to isloate the whole Verticle Processing by Worker Pool thread?

 -Maker Worker Verticle

What if i dont want to isloate the entire Verticle  as worker Verticle , i want to  schedule a few
apis ?

i want to get blocking result , inside non blocking code : coordination between event loop and work pool threads
 - The out put of worker pool thread, need inside event loop thread.

 
  
package com.ibm.vertx.core.async;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class OffLoadVerticle extends AbstractVerticle {

  public void delay() {
    vertx.setPeriodic(5000, handler -> {
      //Blocking event loop thread and get result from blocking api, handover to non blocking api
      vertx.executeBlocking(this::sayHello, this::resultHandler);

    });
  }

  //blocking api
  private void sayHello(Promise<String> promise) {
    System.out.println("Say Hello : " + Thread.currentThread().getName());
    try {
      Thread.sleep(4000);
      System.out.println("Wake Up read to send data to Non blocking Service");
      promise.complete("Hey this is blocking Result");
    } catch (InterruptedException es) {
      promise.fail("Something went wrong in blocking service");
    }
  }

  //read result from blocking service
  private void resultHandler(AsyncResult<String> ar) {
    System.out.println("Result Handler" + Thread.currentThread().getName());
    if (ar.succeeded()) {
      System.out.println("Blocking api Result goes Ready Here");
      System.out.println(ar.result());
    } else {
      System.out.println(ar.cause().getMessage());
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    delay();
  }
}

public class BlockingViaExecuteBlockingApi extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingViaExecuteBlockingApi.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new OffLoadVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Verticles Communication:
......................

How Verticles can communicate each?

  eg

  Controller Verticle         Repository Verticle
             |                 |
             |-----------------|
             

In Spring


Object communication:

class OrderService{

 private OrderRepository repo;

 public OrderService(){
 }

 public OrderService(OrderRepository repo){
       this.repo = repo;
 }
  //setter and getters

  public void saveOrder(Object somedata){
   
        repo.save(somedata);
  }

}

class OrderRepository{

   public void save(Object somedata){}

}

//
OrderRepository repo = new OrderRepository();
OrderService service = new OrderService(repo);
service.saveOrder(somedata);
}

Why object communication?

 data exchange

Any other way these two objects can communicate each other?

Distributed programming, where programs can talk each, distributed objects , can talk each other.

communication channel :  Protocals - tcp/ip, http 


Message Driven Architecture  : MOM

-RabbitMq,Kafka



In Vertx, How objects(Verticles) communicate each other?

 Via MOM like architecture, event bus

What is event Bus?

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.

-Event Bus uses tcp transport layer by default
-Event can send and recive data in the form of json and buffer

How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern

https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

EventBus is also the reference of implementation of microservice design pattern "Pattern: Event sourcing"


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes
  and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Pub-Sub Demo : One to many
package com.ibm.vertx.core.distributed.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

//publisher
class NewsPublisherVerticle extends AbstractVerticle {

  private void publishNews() {
    //pub-sub : publish method on event bus identicates
    vertx.setTimer(5000, ar -> {
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India";
      vertx.eventBus().publish("news.in.covid", news);
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    publishNews();
  }
}

//subscriber-1
class NewsSevenVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//subscriber-2
class BBCVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BCC Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

public class EventBusPubSub extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusPubSub.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //deploy all the verticles
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());

  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Point - Point :



package com.ibm.vertx.core.distributed.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;


//
class CentralFinanceVerticle extends AbstractVerticle {

  private void alertNotification() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("notification.tn.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("Alert From Tamil Nadu : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    alertNotification();
  }
}

//publisher
class NewsPublisherVerticle extends AbstractVerticle {

  //pub and sub
  private void publishNews() {
    //pub-sub : publish method on event bus identicates
    vertx.setTimer(5000, ar -> {
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India";
      vertx.eventBus().publish("news.in.covid", news);
    });

  }

  //point to point
  private void sendNotification() {
    vertx.setTimer(1500, h -> {
      //point-to-point
      vertx.eventBus().send("notification.tn.covid", "We have not received any update on Fund!");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publishNews();
    sendNotification();
  }
}

//subscriber-1
class NewsSevenVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//subscriber-2
class BBCVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BCC Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

public class EventBusPubSub extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusPubSub.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //deploy all the verticles
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new CentralFinanceVerticle());

  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

request-reply with ack:
.......................

package com.ibm.vertx.core.distributed.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;


class HealthEmerencyVerticle extends AbstractVerticle {

  private void requestReply() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("alert.tn.covid");
    //handle/process the message/news
    consumer.handler(alert -> {
      System.out.println("Alert From Hosiptial : " + alert.body());
      //reply sent to publisher
      alert.reply("Patient is crictal!! Need More Attention!!!");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestReply();
  }
}

//
class CentralFinanceVerticle extends AbstractVerticle {

  private void alertNotification() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("notification.tn.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("Alert From Tamil Nadu : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    alertNotification();
  }
}

//publisher
class NewsPublisherVerticle extends AbstractVerticle {

  //pub and sub
  private void publishNews() {
    //pub-sub : publish method on event bus identicates
    vertx.setTimer(5000, ar -> {
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India";
      vertx.eventBus().publish("news.in.covid", news);
    });

  }

  //point to point
  private void sendNotification() {
    vertx.setTimer(1500, h -> {
      //point-to-point
      vertx.eventBus().send("notification.tn.covid", "We have not received any update on Fund!");
    });
  }
  private void sendAlert() {
    vertx.setTimer(100, h -> {
      //request-reply
      vertx.eventBus().request("alert.tn.covid", "We have send medical Reports of Mr X", ar -> {
        if (ar.succeeded()) {
          System.out.println("Reply/Response : " + ar.result().body());
        }
      });
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publishNews();
    sendNotification();
    sendAlert();
  }
}

//subscriber-1
class NewsSevenVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

//subscriber-2
class BBCVerticle extends AbstractVerticle {

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      System.out.println("BCC Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

public class EventBusPubSub extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusPubSub.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //deploy all the verticles
    vertx.deployVerticle(new NewsPublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new CentralFinanceVerticle());
    vertx.deployVerticle(new HealthEmerencyVerticle());

  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Formate:

Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically
 as you write data to it.

package com.ibm.vertx.core.dataformats;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferDemo  extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Buffer
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}
********************************************************************************************************
JSON Object :Data Interchange format 

Vertx provides a Json Objects

1.JsonObject
2.JsonArray


package com.ibm.vertx.core.dataformats;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class Vistior extends AbstractVerticle {

  public Future<JsonObject> getVisitor() {
    Promise promise = Promise.promise();
    JsonObject address = new JsonObject();
    address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
    JsonObject visitor = new JsonObject();
    visitor.put("name", "subramanian").put("address", address);
    promise.complete(visitor);
    return promise.future();
  }

  public Future<JsonArray> getVisitorList() {
    Promise promise = Promise.promise();

    JsonObject address = new JsonObject();
    address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
    JsonObject visitor = new JsonObject();
    visitor.put("name", "subramanian").put("address", address);

    JsonArray list = new JsonArray();
    list.add(visitor).add(visitor).add(visitor).add(visitor);
    promise.complete(list);

    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
    getVisitor().onComplete(jsonObjectAsyncResult -> {
      System.out.println(jsonObjectAsyncResult.result().encodePrettily());
    });
    getVisitorList().onComplete(jsonObjectAsyncResult -> {
      System.out.println(jsonObjectAsyncResult.result().encodePrettily());
    });
    getVisitorList().onComplete(jsonObjectAsyncResult -> {
      jsonObjectAsyncResult.result().forEach(visitor -> {
        System.out.println(visitor);
      });
    });
  }
}

public class JSONDemo extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONDemo.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new Vistior());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

NON Blocking Web:
.................
How to build non blocking web application

vertx offers low level api called
 vertx.createHttpServer()

Objects:

1.HttpServer
2.HttpServerRequest
3.HttpServerResponse
All these objects are created already by vertx and only we references.


package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

public class BasicHttpServer extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BasicHttpServer.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
//    HttpServer httpServer = vertx.createHttpServer();
//    //handle request and reponse
//    httpServer.requestHandler(request -> {
//      //send response
//      HttpServerResponse response = request.response();
//      //send /write response  and close the stream together
//      response.end("<h1>Hello Vertx Web Server!!</h1>");
//    });
//   //start server
//    httpServer.listen(3000, httpServerAsyncResult -> {
//      System.out.println("Vertx - HTTP Server is Ready!!!");
//    });
    //Fluent pattern
    vertx.createHttpServer()
      .requestHandler(request -> {
        //send response
        request.response().end("<h1>Hello Vertx Web Server!!</h1>");
      })
      .listen(3000, httpServerAsyncResult -> {
        System.out.println("Vertx - HTTP Server is Ready!!!");
      });

  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

In Vertx , you dont need to use third party web containers/server ; tomcat.

Vertx provides

1.write your own server
	vertx.createServer
2.write app
	server.requestHandler 
3.deploy app on that server.
        listen and request handling


Whatif i want realtime server configurations
 -host name
 -ssl configuration
 ....

Vertx offers an configuration Object called "HTTPServerConfiguration"

package com.ibm.vertx.core.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class HttpServerWithOptions extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpServerWithOptions.class);
  }

  @Override
  public void start() throws Exception {
    super.start();

    //HttpServer options
    HttpServerOptions options = new HttpServerOptions().setPort(3002);
    //options.setPort(3002);
    //create WebServer , Handle request  and Send Response
    HttpServer server = vertx.createHttpServer(options);
    //Handle Request
    server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.end("<h1>Hello Vertx Application</h1>");
    });


    //start server
    server.listen(serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

HOW TO Write web agent program? - restTemplate in spring:
.........................................................

Verticle communications

1.Event bus
2.HTTP protocal

Vertx provides two implementation.

-from io.vertx.core.http
-from webclient module


Server Verticle :

package com.ibm.vertx.core.http.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class HttpServerVerticle extends AbstractVerticle {

  private void startApp() {
    //HttpServer options
    HttpServerOptions options = new HttpServerOptions();
    options.setPort(3001);
    //create WebServer , Handle request  and Send Response

    HttpServer server = vertx.createHttpServer(options);

    //Handle Request
    server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.putHeader("content-type", "application/json");
      JsonObject address = new JsonObject();
      address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
      JsonObject visitor = new JsonObject();
      visitor.put("name", "subramanian").put("address", address);
      //response.end("<h1>Hello Vertx Application</h1>");
      response.end(visitor.encodePrettily());
    });
    server.listen(serverHandler -> {
      if (serverHandler.succeeded()) {
        System.out.println("Http Server is up and running");
      } else {
        System.out.println(serverHandler.cause().getMessage());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    startApp();
  }
}


public class ServerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(ServerVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new HttpServerVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

HTTP Client Program:

package com.ibm.vertx.core.http.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.HttpMethod;
import io.vertx.example.util.Runner;

class ClientVerticle extends AbstractVerticle {

  private void startRequest() {
    HttpClientOptions options = new HttpClientOptions();
    HttpClient client = vertx.createHttpClient(options);
    client.request(HttpMethod.GET, 3001, "localhost", "/", res -> {
      System.out.println("Status : " + res.statusCode());
      //handle response /result
      res.bodyHandler(payload -> {
        System.out.println(payload);
      });
    }).end();

  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.setTimer(1000, ar -> {
      startRequest();
    });
  }
}


public class HttpClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HttpClientVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ClientVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Problems with core httpServer:
............................

1.routers and uri mapping.

/api/users - GET,POST,DELETE,PUT,

  server.requestHandler(context -> {
      //context is container object , having HttpResponse and HttpRequest.
      HttpServerResponse response = context.response();
      response.putHeader("content-type", "application/json");
      JsonObject address = new JsonObject();
      address.put("city", "coimbatore").put("street", "10th street").put("state", "Tamil Nadu");
      JsonObject visitor = new JsonObject();
      visitor.put("name", "subramanian").put("address", address);
      //response.end("<h1>Hello Vertx Application</h1>");
      response.end(visitor.encodePrettily());
    });

We need abstraction, vertx provides a module called web.


Using Vert.x Web:

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web</artifactId>
 <version>3.9.2</version>
</dependency>

Types of WebApps:
.................
1.Static web - 1989-1995
2.Dynamic content generation web apps - 1996 - till date
   -eg ; servlets,jsp,aspx,php- with templates- html is output
3.Resource based web apps - 1999 - till date
  -Webservice - xml based(soap) , Data independent based(REST)
4.Single Page Web Apps - using javascript
  -Frameworks-angular,react.....


How to build non blocking RESTFull Web Services?

Resource based web Application , where data is returned in different format.

domain model

Methods URL Patterns

GET  /api/users/list
POST /api/users
GET  /api/users/1
PUT  /api/users/1

Can you build realtime REST Apps using core http module

 Yes,but very complex

Vertx Provides a module  - vertx-web
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Web Module is not independant , just an extension to core vertx http.
----------------------------------------------------------------------


				     vertx-Web
				         |
					HTTP



Routing:
........
To map urls with http methods

 /api/greet   ------GET

Rotuer
Route
RotuingContext
  -HTTPServerRequest
  -HttpServerReponse
	


package com.ibm.vertx.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;

class HelloController extends AbstractVerticle {

  //ROUTER COnfiguration
  public Router getHelloRouterConfig() {
    Router router = Router.router(vertx);
    //rest end point happing
    router.get("/hello").handler(routingContext -> {
      routingContext.response().end("Hello");
    });
    router.get("/helloagain").handler(routingContext -> {
      routingContext.response().end("Hello Again");
    });

    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}

class HaiController extends AbstractVerticle {

  //ROUTER COnfiguration
  public Router getHaiRouterConfig() {
    Router router = Router.router(vertx);
    //rest end point happing
    router.get("/hai").handler(routingContext -> {
      routingContext.response().end("Hai");
    });
    router.get("/haiagain").handler(routingContext -> {
      routingContext.response().end("Hai Again");
    });

    return router;
  }

  @Override
  public void start() throws Exception {
    super.start();
  }
}

public class WebApplication extends AbstractVerticle {

  HttpServer server;
  HttpServerOptions options;

  public static void main(String[] args) {
    Runner.runExample(WebApplication.class);
  }

  public void StartApp() {
    options = new HttpServerOptions().setPort(3001).setHost("localhost");
    server = vertx.createHttpServer(options);

    //Router Registeration
    Router appRouter = Router.router(vertx);
    //bind urls
    appRouter.mountSubRouter("/api/helloapp", new HelloController().getHelloRouterConfig());
    appRouter.mountSubRouter("/api/haiapp", new HaiController().getHaiRouterConfig());

    //route all http requests
    server.requestHandler(appRouter);


    //start
    server.listen(server -> {
      if (server.succeeded()) {
        System.out.println("REST Api Server is Ready!");
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new HelloController());
    vertx.deployVerticle(new HaiController());
    StartApp();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data base integration :

 In vertx everthing is non blocking.

SQL -oracle,sqlserver,mssql- jdbc
NOSQL-Mongo



MongoDB :

A Vert.x client allowing applications to interact with a MongoDB instance, whether that’s saving, retrieving, searching, or deleting documents. Mongo is a great match for persisting data in a Vert.x application as it natively handles JSON (BSON) documents.

Features

-Completely non-blocking

-Custom codec to support fast serialization to/from Vert.x JSON

-Supports a majority of the configuration options from the MongoDB Java Driver

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-mongo-client</artifactId>
 <version>3.9.2</version>
</dependency>


package com.ibm.vertx.web.data;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.mongo.MongoClient;
import io.vertx.ext.web.Router;

class BooksRepository extends AbstractVerticle {
  MongoClient mongoClient;

  public BooksRepository() {
  }

  public BooksRepository(MongoClient mongoClient) {
    this.mongoClient = mongoClient;
  }

  //biz api :return records via promise
  public Future<String> findAll() {
    Promise promise = Promise.promise();
    mongoClient.find("books", new JsonObject(), listAsyncResult -> {
      if (listAsyncResult.succeeded()) {
        //Store results in jsonArray
        JsonArray documents = new JsonArray();
        for (JsonObject document : listAsyncResult.result()) {
          documents.add(document);
        }
        promise.complete(documents.encodePrettily());

      } else {
        promise.fail(listAsyncResult.cause().getMessage());
      }
    });


    return promise.future();
  }
}

class BooksController extends AbstractVerticle {

  private BooksRepository bookRepository;

  public BooksController() {
  }

  public BooksController(MongoClient mongoClient) {
    bookRepository = new BooksRepository(mongoClient);
  }

  //booksRouter
  public Router getBooksConfig() {
    //sub Routers
    Router router = Router.router(vertx);
    //end points
    router.get("/list").handler(ctx -> {

      //talk to book repo class to get records async, once the result is ready,send to client
      bookRepository.findAll().onComplete(ar -> {
        //verify result
        if (ar.succeeded()) {
          //set Header content type
          ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/json");
          //flush the response
          ctx.response().end(ar.result());
        } else {
          ctx.response().end("Sorry Somthing went Wrong!!!!");
        }

      });


    });

    return router;
  }
}


public class WebAppMongo extends AbstractVerticle {

  HttpServer server;
  HttpServerOptions options;
  MongoClient mongoClient;

  public static void main(String[] args) {
    Runner.runExample(WebAppMongo.class);
  }

  public void StartApp() {
    options = new HttpServerOptions().setPort(3001).setHost("localhost");
    server = vertx.createHttpServer(options);

    //Mongo db connection

    //connecting mongo db
    mongoClient = MongoClient.createShared(vertx, new JsonObject().put("db_name", "booksdb"));
    BooksController booksController = new BooksController(mongoClient);


    //Router Registeration
    Router appRouter = Router.router(vertx);
    //bind urls
    appRouter.mountSubRouter("/api/books", booksController.getBooksConfig());
    //route all http requests
    server.requestHandler(appRouter);


    //start
    server.listen(server -> {
      if (server.succeeded()) {
        System.out.println("REST Api Server is Ready!");
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    StartApp();
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

JDBC,SQL,Templates: Dynamic web Application:
.............................................


FreeMarker template Engine
JDBC - HSQL DB
vertx-Web - routing

Depedencies
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-jdbc-client</artifactId>
 <version>3.9.1</version>
</dependency>

    <dependency>
      <groupId>com.github.rjeschke</groupId>
      <artifactId>txtmark</artifactId>
      <version>0.13</version>
    </dependency>

   <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>2.0.0-alpha1</version>
    </dependency>
    <dependency>
      <groupId>org.hsqldb</groupId>
      <artifactId>hsqldb</artifactId>
      <version>2.5.0</version>
    </dependency>
 <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-templ-freemarker</artifactId>
    </dependency>

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

veticle start method with promise overloaded version :

Database
WebServer

start(Promise promise)
 deploy ----start completion ensures, that deployment is over
 inside start, you are initalizing some non blocking resources, starting db,populating data
 staring http servers which may be waiting for some resources

what if start has completed, but still http or db not ready, then it will create inconsistency

dont confirm the start method completion until, all resources are initalized.

use start overloaded promise version.

RoutingContext : Container Object in vertx which contains Request and Response.
    -can be used to exchange
  contex.put("key","value")
 -ServletContext: 
      - used to exchange data between servlets
    put("key","value")

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Basic Templates:

package com.ibm.vertx.web.data;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.templ.freemarker.FreeMarkerTemplateEngine;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.stream.Collectors;

class BlogVerticle extends AbstractVerticle {
  //sql statements
  private static final String SQL_CREATE_PAGES_TABLE = "create table if not exists Pages (Id integer identity primary key, Name varchar(255) unique, Content clob)";
  private static final String SQL_GET_PAGE = "select Id, Content from Pages where Name = ?"; // <1>
  private static final String SQL_CREATE_PAGE = "insert into Pages values (NULL, ?, ?)";
  private static final String SQL_SAVE_PAGE = "update Pages set Content = ? where Id = ?";
  private static final String SQL_ALL_PAGES = "select Name from Pages";
  private static final String SQL_DELETE_PAGE = "delete from Pages where Id = ?";
  //Logger
  private static final Logger LOGGER = LoggerFactory.getLogger(BlogVerticle.class);
  //jdbc driver
  private JDBCClient dbClient;
  //Template Engine reference
  private FreeMarkerTemplateEngine templateEngine;

  //resource initalizatio apis : database,http server
  //initialize the database and create initial table
  private Future<Void> prepareDatabase() {
    Promise<Void> promise = Promise.promise();
    //connection information
    dbClient = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:file:db/wiki")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30));

    //db inital setup
    dbClient.getConnection(ar -> {
      if (ar.failed()) {
        LOGGER.error("Could not open a database connection", ar.cause());
        promise.fail(ar.cause());

      } else {
        SQLConnection connection = ar.result();

        connection.execute(SQL_CREATE_PAGES_TABLE, create -> {
          connection.close();
          if (create.failed()) {
            LOGGER.error("Database preparation error", create.cause());
            promise.fail(create.cause());
          } else {
            promise.complete();
          }
        });
      }
    });


    return promise.future();
  }

  //to display home page
  private void indexHandler(RoutingContext context) {

    dbClient.getConnection(car -> {
      if (car.succeeded()) {
        SQLConnection connection = car.result();

        connection.query(SQL_ALL_PAGES, res -> {
          connection.close();

          if (res.succeeded()) {
            //java streams -replace with RX-JAVA improve performance
            List<String> pages = res.result()
              .getResults()
              .stream()
              .map(json -> json.getString(0))
              .sorted()
              .collect(Collectors.toList());

            //this will be accessed inside Template
            context.put("title", "IBM Wiki home");
            context.put("pages", pages);

            //Prepare Templates,convert into html(final output
            templateEngine.render(context.data(), "templates/index.ftl", ar -> {   //
              if (ar.succeeded()) {
                context.response().putHeader("Content-Type", "text/html");
                context.response().end(ar.result());
              } else {
                context.fail(ar.cause());
              }
            });

          } else {
            context.fail(res.cause());
          }
        });
      } else {
        context.fail(car.cause());
      }
    });
  }

  //starting http server
  private Future<Void> startHttpServer() {
    Promise<Void> promise = Promise.promise();

    HttpServer server = vertx.createHttpServer();
    Router router = Router.router(vertx);
    //write all routes here , later we can isloate routers

    router.get("/").handler(this::indexHandler);

    templateEngine = FreeMarkerTemplateEngine.create(vertx);

    server
      .requestHandler(router)
      .listen(3001, ar -> {
        if (ar.succeeded()) {
          LOGGER.info("HTTP server running on port 8080");
          promise.complete();
        } else {
          LOGGER.error("Could not start a HTTP server", ar.cause());
          promise.fail(ar.cause());
        }
      });

    return promise.future();

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    Future<Void> steps = prepareDatabase().compose(v -> startHttpServer());
    //ensure here start now can complete
    steps.onComplete(startPromise);
  }
}

public class DynamicWebApp extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(DynamicWebApp.class);
  }

  @Override
  public void start() throws Exception {
    vertx.deployVerticle(new BlogVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Distributed Architecture: Microservices
.......................................


Verticle Communication:
......................

1.Within Process : 

  Within single Vertx

2.among Vertx


Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

Vertx.createClusteredVertx()


2.through vertx command line

  vertx program.java -cluster



Steps for clustering:
....................

<dependency>
      <groupId>com.hazelcast</groupId>
      <artifactId>hazelcast</artifactId>
      <version>3.12.2</version>
</dependency>


Cluster Configuration:

two ways

1.through code

2.through configuration files
 -hazelcast uses file  cluster.xml

Create ClusteManager

Config hazelcastConfig = new Config();

// Now set some stuff on the config (omitted)

ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);


default configuration:

ClusterManager mgr = new HazelcastClusterManager(hazelcastConfig);

    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr);
    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {

       //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions();       
        
        vertxAsyncResult.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Pubilsher:
package com.ibm.vertx.core.distributed.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr);
    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {

       //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions();

        vertxAsyncResult.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    // System.out.println("JVM Name = " + jvmName);
    long pid = Long.valueOf(jvmName.split("@")[0]);
    //System.out.println(Thread.currentThread().getName());
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });
  }
}

package com.ibm.vertx.core.distributed.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class SubscriberVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();

    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        DeploymentOptions deploymentOptions = new DeploymentOptions();
         cluster.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.SubscriberVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("JVM Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Load balancing and fail over: Scalability
...............................................................................................

what if the one verticle which was deployed down , due to various reasons.


You set no of instances of same the verticle .

Via Code

DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(5);

Note: No of instances can be set in cluster and non cluster mode


via commandline

vertx programname -cluster -instances=5


Load Balancer: High Availablity:
................................
Via Code

DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(5).setHA(true);

   " Here i want to replicate 10 copies of Subscriber Verticle and also enables built in load balancer
        //which scales automatically when verticles goes off.
        DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(10).setHa(true);
     "



via commandline

vertx programname -cluster -instances=5


package com.ibm.vertx.core.distributed.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class SubscriberVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();

    VertxOptions options = new VertxOptions().setClusterManager(mgr);

    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        //Here i want to replicate 10 copies of Subscriber Verticle and also enables built in load balancer
        //which scales automatically when verticles goes off.
        DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(10).setHa(true);

         cluster.result().deployVerticle("com.ibm.vertx.core.distributed.cluster.SubscriberVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("JVM Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.ibm.vertx.core.distributed.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;


public class HighAvailbilityApp extends AbstractVerticle {

  @Override
  public void start() {

    HttpServer server = vertx.createHttpServer();

    server.requestHandler(req -> {
      long id = Thread.currentThread().getId();
      req.response().end("<h1> I am coming from " + id + " Instance");
    });

    server.listen(8888, "localhost", handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is Ready! " + Thread.currentThread().getId());
      } else {
        System.out.println("Server failed to Start");
      }
    });
  }


}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Distributed App Configuration: Centralized configuration system:

Vert.x Config:

This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties

In memory Store: Application memory

Configuration via JSON objects, can be kept at memory.


Storage file formats:
1.yaml
2.json
3.properties
......

Concepts:

1.How to process / read configurations

Vertx Provides non blocking Object

1.ConfigRetriever:

  It configures a set of configuration store, where Configuration store defines  a location
from where the configuration data is read and also format(JSON by default).

 The Result from ConfigServer is JSON object.

Flow

  Application ------------------|ConfigRetriver----|ConfigStore
				JSON Object	<----	


How to instantiate the ConfigRetriver:

 ConfigRetriver retriver = ConfigRetriver.create(vertx).


///////////////////////////////////////////////////////////////////////////////////////////

ConfigRetiver Object can be used to read from physical storage and also in memory.

AbstractVerticle has an api called

public JsonObject config()
Get the configuration of the verticle.
This can be specified when the verticle is deployed.

JSONObject config(); --this method interanally uses Builtin ConfigRetriver.

 get("key","defaultValue") - to read values from the memory
   get("message","Hello")
 put("key",value) - to store configuration data to verticles /application

/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
Order of config property retrival:

get("SOMETHING")------> Verticle---Not----System Proptiers---->Env--->Store

1.The vertx Verticle config()
2.The system properties
3.The environment variables
4.From the store what you have configurated
/////////////////////////////////////////////////////////////////////////////////////////

Implemetation:

1.Type of Store
  ->ConfigStoreOptions

2.Create ConfigRetriver Object with ConfigStore options


   <dependency>
       <groupId>io.vertx</groupId>
       <artifactId>vertx-config-yaml</artifactId>
    </dependency>

     <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-config</artifactId>
    </dependency>



1.create json file

resources/application.json
{
  "application": {
    "name": "Unisys Vertx Application",
    "Version": "1.0.0",
    "port": 3001
  }
}









